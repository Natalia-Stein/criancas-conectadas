/** @license React vundefined
 * react-refresh-babel.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

function ReactFreshBabelPlugin (babel) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof babel.env === 'function') {
    // Only available in Babel 7.
    var env = babel.env();

    if (env !== 'development' && !opts.skipEnvCheck) {
      throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: "' + env + '". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');
    }
  }

  var t = babel.types;
  var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');
  var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');
  var registrationsByProgramPath = new Map();

  function createRegistration(programPath, persistentID) {
    var handle = programPath.scope.generateUidIdentifier('c');

    if (!registrationsByProgramPath.has(programPath)) {
      registrationsByProgramPath.set(programPath, []);
    }

    var registrations = registrationsByProgramPath.get(programPath);
    registrations.push({
      handle: handle,
      persistentID: persistentID
    });
    return handle;
  }

  function isComponentishName(name) {
    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';
  }

  function findInnerComponents(inferredName, path, callback) {
    var node = path.node;

    switch (node.type) {
      case 'Identifier':
        {
          if (!isComponentishName(node.name)) {
            return false;
          } // export default hoc(Foo)
          // const X = hoc(Foo)


          callback(inferredName, node, null);
          return true;
        }

      case 'FunctionDeclaration':
        {
          // function Foo() {}
          // export function Foo() {}
          // export default function Foo() {}
          callback(inferredName, node.id, null);
          return true;
        }

      case 'ArrowFunctionExpression':
        {
          if (node.body.type === 'ArrowFunctionExpression') {
            return false;
          } // let Foo = () => {}
          // export default hoc1(hoc2(() => {}))


          callback(inferredName, node, path);
          return true;
        }

      case 'FunctionExpression':
        {
          // let Foo = function() {}
          // const Foo = hoc1(forwardRef(function renderFoo() {}))
          // export default memo(function() {})
          callback(inferredName, node, path);
          return true;
        }

      case 'CallExpression':
        {
          var argsPath = path.get('arguments');

          if (argsPath === undefined || argsPath.length === 0) {
            return false;
          }

          var calleePath = path.get('callee');

          switch (calleePath.node.type) {
            case 'MemberExpression':
            case 'Identifier':
              {
                var calleeSource = calleePath.getSource();
                var firstArgPath = argsPath[0];
                var innerName = inferredName + '$' + calleeSource;
                var foundInside = findInnerComponents(innerName, firstArgPath, callback);

                if (!foundInside) {
                  return false;
                } // const Foo = hoc1(hoc2(() => {}))
                // export default memo(React.forwardRef(function() {}))


                callback(inferredName, node, path);
                return true;
              }

            default:
              {
                return false;
              }
          }
        }

      case 'VariableDeclarator':
        {
          var init = node.init;

          if (init === null) {
            return false;
          }

          var name = node.id.name;

          if (!isComponentishName(name)) {
            return false;
          }

          switch (init.type) {
            case 'ArrowFunctionExpression':
            case 'FunctionExpression':
              // Likely component definitions.
              break;

            case 'CallExpression':
              {
                // Maybe a HOC.
                // Try to determine if this is some form of import.
                var callee = init.callee;
                var calleeType = callee.type;

                if (calleeType === 'Import') {
                  return false;
                } else if (calleeType === 'Identifier') {
                  if (callee.name.indexOf('require') === 0) {
                    return false;
                  } else if (callee.name.indexOf('import') === 0) {
                    return false;
                  } // Neither require nor import. Might be a HOC.
                  // Pass through.

                }

                break;
              }

            case 'TaggedTemplateExpression':
              // Maybe something like styled.div`...`
              break;

            default:
              return false;
          }

          var initPath = path.get('init');

          var _foundInside = findInnerComponents(inferredName, initPath, callback);

          if (_foundInside) {
            return true;
          } // See if this identifier is used in JSX. Then it's a component.


          var binding = path.scope.getBinding(name);

          if (binding === undefined) {
            return;
          }

          var isLikelyUsedAsType = false;
          var referencePaths = binding.referencePaths;

          for (var i = 0; i < referencePaths.length; i++) {
            var ref = referencePaths[i];

            if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {
              continue;
            }

            var refParent = ref.parent;

            if (refParent.type === 'JSXOpeningElement') {
              isLikelyUsedAsType = true;
            } else if (