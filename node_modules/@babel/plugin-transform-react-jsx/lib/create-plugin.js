"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createPlugin;
var _pluginSyntaxJsx = require("@babel/plugin-syntax-jsx");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _helperModuleImports = require("@babel/helper-module-imports");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
const DEFAULT = {
  importSource: "react",
  runtime: "automatic",
  pragma: "React.createElement",
  pragmaFrag: "React.Fragment"
};
const JSX_SOURCE_ANNOTATION_REGEX = /^\s*\*?\s*@jsxImportSource\s+([^\s]+)\s*$/m;
const JSX_RUNTIME_ANNOTATION_REGEX = /^\s*\*?\s*@jsxRuntime\s+([^\s]+)\s*$/m;
const JSX_ANNOTATION_REGEX = /^\s*\*?\s*@jsx\s+([^\s]+)\s*$/m;
const JSX_FRAG_ANNOTATION_REGEX = /^\s*\*?\s*@jsxFrag\s+([^\s]+)\s*$/m;
const get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);
const set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);
function hasProto(node) {
  return node.properties.some(value => _core.types.isObjectProperty(value, {
    computed: false,
    shorthand: false
  }) && (_core.types.isIdentifier(value.key, {
    name: "__proto__"
  }) || _core.types.isStringLiteral(value.key, {
    value: "__proto__"
  })));
}
function createPlugin({
  name,
  development
}) {
  return (0, _helperPluginUtils.declare)((_, options) => {
    const {
      pure: PURE_ANNOTATION,
      throwIfNamespace = true,
      filter,
      runtime: RUNTIME_DEFAULT = development ? "automatic" : "classic",
      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,
      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,
      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag
    } = options;
    {
      var {
        useSpread = false,
        useBuiltIns = false
      } = options;
      if (RUNTIME_DEFAULT === "classic") {
        if (typeof useSpread !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
        }
        if (typeof useBuiltIns !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
        }
        if (useSpread && useBuiltIns) {
          throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
        }
      }
    }
    const injectMetaPropertiesVisitor = {
      JSXOpeningElement(path, state) {
        const attributes = [];
        if (isThisAllowed(path.scope)) {
          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__self"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));
        }
        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__source"), _core.types.jsxExpressionContainer(makeSource(path, state))));
        path.pushContainer("attributes", attributes);
      }
    };
    return {
      name,
      inherits: _pluginSyntaxJsx.default,
      visitor: {
        JSXNamespacedName(path) {
          if (throwIfNamespace) {
            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \
